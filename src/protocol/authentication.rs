// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by protoc 33.2
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `authentication.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

// @@protoc_insertion_point(message:ClientResponseEncrypted)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ClientResponseEncrypted {
    // message fields
    // @@protoc_insertion_point(field:ClientResponseEncrypted.login_credentials)
    pub login_credentials: ::protobuf::MessageField<LoginCredentials>,
    // @@protoc_insertion_point(field:ClientResponseEncrypted.account_creation)
    pub account_creation: ::std::option::Option<::protobuf::EnumOrUnknown<AccountCreation>>,
    // @@protoc_insertion_point(field:ClientResponseEncrypted.fingerprint_response)
    pub fingerprint_response: ::protobuf::MessageField<FingerprintResponseUnion>,
    // @@protoc_insertion_point(field:ClientResponseEncrypted.peer_ticket)
    pub peer_ticket: ::protobuf::MessageField<PeerTicketUnion>,
    // @@protoc_insertion_point(field:ClientResponseEncrypted.system_info)
    pub system_info: ::protobuf::MessageField<SystemInfo>,
    // @@protoc_insertion_point(field:ClientResponseEncrypted.platform_model)
    pub platform_model: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ClientResponseEncrypted.version_string)
    pub version_string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ClientResponseEncrypted.appkey)
    pub appkey: ::protobuf::MessageField<LibspotifyAppKey>,
    // @@protoc_insertion_point(field:ClientResponseEncrypted.client_info)
    pub client_info: ::protobuf::MessageField<ClientInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:ClientResponseEncrypted.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClientResponseEncrypted {
    fn default() -> &'a ClientResponseEncrypted {
        <ClientResponseEncrypted as ::protobuf::Message>::default_instance()
    }
}

impl ClientResponseEncrypted {
    pub fn new() -> ClientResponseEncrypted {
        ::std::default::Default::default()
    }

    // optional .AccountCreation account_creation = 20;

    pub fn account_creation(&self) -> AccountCreation {
        match self.account_creation {
            Some(e) => e.enum_value_or(AccountCreation::ACCOUNT_CREATION_ALWAYS_PROMPT),
            None => AccountCreation::ACCOUNT_CREATION_ALWAYS_PROMPT,
        }
    }

    pub fn clear_account_creation(&mut self) {
        self.account_creation = ::std::option::Option::None;
    }

    pub fn has_account_creation(&self) -> bool {
        self.account_creation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_creation(&mut self, v: AccountCreation) {
        self.account_creation = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string platform_model = 60;

    pub fn platform_model(&self) -> &str {
        match self.platform_model.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_platform_model(&mut self) {
        self.platform_model = ::std::option::Option::None;
    }

    pub fn has_platform_model(&self) -> bool {
        self.platform_model.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform_model(&mut self, v: ::std::string::String) {
        self.platform_model = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_platform_model(&mut self) -> &mut ::std::string::String {
        if self.platform_model.is_none() {
            self.platform_model = ::std::option::Option::Some(::std::string::String::new());
        }
        self.platform_model.as_mut().unwrap()
    }

    // Take field
    pub fn take_platform_model(&mut self) -> ::std::string::String {
        self.platform_model.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string version_string = 70;

    pub fn version_string(&self) -> &str {
        match self.version_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version_string(&mut self) {
        self.version_string = ::std::option::Option::None;
    }

    pub fn has_version_string(&self) -> bool {
        self.version_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_string(&mut self, v: ::std::string::String) {
        self.version_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_string(&mut self) -> &mut ::std::string::String {
        if self.version_string.is_none() {
            self.version_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_version_string(&mut self) -> ::std::string::String {
        self.version_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LoginCredentials>(
            "login_credentials",
            |m: &ClientResponseEncrypted| { &m.login_credentials },
            |m: &mut ClientResponseEncrypted| { &mut m.login_credentials },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_creation",
            |m: &ClientResponseEncrypted| { &m.account_creation },
            |m: &mut ClientResponseEncrypted| { &mut m.account_creation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FingerprintResponseUnion>(
            "fingerprint_response",
            |m: &ClientResponseEncrypted| { &m.fingerprint_response },
            |m: &mut ClientResponseEncrypted| { &mut m.fingerprint_response },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PeerTicketUnion>(
            "peer_ticket",
            |m: &ClientResponseEncrypted| { &m.peer_ticket },
            |m: &mut ClientResponseEncrypted| { &mut m.peer_ticket },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SystemInfo>(
            "system_info",
            |m: &ClientResponseEncrypted| { &m.system_info },
            |m: &mut ClientResponseEncrypted| { &mut m.system_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "platform_model",
            |m: &ClientResponseEncrypted| { &m.platform_model },
            |m: &mut ClientResponseEncrypted| { &mut m.platform_model },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version_string",
            |m: &ClientResponseEncrypted| { &m.version_string },
            |m: &mut ClientResponseEncrypted| { &mut m.version_string },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LibspotifyAppKey>(
            "appkey",
            |m: &ClientResponseEncrypted| { &m.appkey },
            |m: &mut ClientResponseEncrypted| { &mut m.appkey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ClientInfo>(
            "client_info",
            |m: &ClientResponseEncrypted| { &m.client_info },
            |m: &mut ClientResponseEncrypted| { &mut m.client_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClientResponseEncrypted>(
            "ClientResponseEncrypted",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClientResponseEncrypted {
    const NAME: &'static str = "ClientResponseEncrypted";

    fn is_initialized(&self) -> bool {
        if self.login_credentials.is_none() {
            return false;
        }
        if self.system_info.is_none() {
            return false;
        }
        for v in &self.login_credentials {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fingerprint_response {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.peer_ticket {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.system_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.appkey {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.client_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.login_credentials)?;
                },
                160 => {
                    self.account_creation = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                242 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fingerprint_response)?;
                },
                322 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.peer_ticket)?;
                },
                402 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.system_info)?;
                },
                482 => {
                    self.platform_model = ::std::option::Option::Some(is.read_string()?);
                },
                562 => {
                    self.version_string = ::std::option::Option::Some(is.read_string()?);
                },
                642 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.appkey)?;
                },
                722 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.client_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.login_credentials.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.account_creation {
            my_size += ::protobuf::rt::int32_size(20, v.value());
        }
        if let Some(v) = self.fingerprint_response.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.peer_ticket.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.system_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.platform_model.as_ref() {
            my_size += ::protobuf::rt::string_size(60, &v);
        }
        if let Some(v) = self.version_string.as_ref() {
            my_size += ::protobuf::rt::string_size(70, &v);
        }
        if let Some(v) = self.appkey.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.client_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.login_credentials.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.account_creation {
            os.write_enum(20, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.fingerprint_response.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        }
        if let Some(v) = self.peer_ticket.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(40, v, os)?;
        }
        if let Some(v) = self.system_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(50, v, os)?;
        }
        if let Some(v) = self.platform_model.as_ref() {
            os.write_string(60, v)?;
        }
        if let Some(v) = self.version_string.as_ref() {
            os.write_string(70, v)?;
        }
        if let Some(v) = self.appkey.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(80, v, os)?;
        }
        if let Some(v) = self.client_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(90, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClientResponseEncrypted {
        ClientResponseEncrypted::new()
    }

    fn clear(&mut self) {
        self.login_credentials.clear();
        self.account_creation = ::std::option::Option::None;
        self.fingerprint_response.clear();
        self.peer_ticket.clear();
        self.system_info.clear();
        self.platform_model = ::std::option::Option::None;
        self.version_string = ::std::option::Option::None;
        self.appkey.clear();
        self.client_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClientResponseEncrypted {
        static instance: ClientResponseEncrypted = ClientResponseEncrypted {
            login_credentials: ::protobuf::MessageField::none(),
            account_creation: ::std::option::Option::None,
            fingerprint_response: ::protobuf::MessageField::none(),
            peer_ticket: ::protobuf::MessageField::none(),
            system_info: ::protobuf::MessageField::none(),
            platform_model: ::std::option::Option::None,
            version_string: ::std::option::Option::None,
            appkey: ::protobuf::MessageField::none(),
            client_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClientResponseEncrypted {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClientResponseEncrypted").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClientResponseEncrypted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientResponseEncrypted {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:LoginCredentials)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LoginCredentials {
    // message fields
    // @@protoc_insertion_point(field:LoginCredentials.username)
    pub username: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:LoginCredentials.typ)
    pub typ: ::std::option::Option<::protobuf::EnumOrUnknown<AuthenticationType>>,
    // @@protoc_insertion_point(field:LoginCredentials.auth_data)
    pub auth_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:LoginCredentials.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoginCredentials {
    fn default() -> &'a LoginCredentials {
        <LoginCredentials as ::protobuf::Message>::default_instance()
    }
}

impl LoginCredentials {
    pub fn new() -> LoginCredentials {
        ::std::default::Default::default()
    }

    // optional string username = 10;

    pub fn username(&self) -> &str {
        match self.username.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_username(&mut self) {
        self.username = ::std::option::Option::None;
    }

    pub fn has_username(&self) -> bool {
        self.username.is_some()
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        if self.username.is_none() {
            self.username = ::std::option::Option::Some(::std::string::String::new());
        }
        self.username.as_mut().unwrap()
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        self.username.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .AuthenticationType typ = 20;

    pub fn typ(&self) -> AuthenticationType {
        match self.typ {
            Some(e) => e.enum_value_or(AuthenticationType::AUTHENTICATION_USER_PASS),
            None => AuthenticationType::AUTHENTICATION_USER_PASS,
        }
    }

    pub fn clear_typ(&mut self) {
        self.typ = ::std::option::Option::None;
    }

    pub fn has_typ(&self) -> bool {
        self.typ.is_some()
    }

    // Param is passed by value, moved
    pub fn set_typ(&mut self, v: AuthenticationType) {
        self.typ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bytes auth_data = 30;

    pub fn auth_data(&self) -> &[u8] {
        match self.auth_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_auth_data(&mut self) {
        self.auth_data = ::std::option::Option::None;
    }

    pub fn has_auth_data(&self) -> bool {
        self.auth_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auth_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.auth_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.auth_data.is_none() {
            self.auth_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.auth_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_auth_data(&mut self) -> ::std::vec::Vec<u8> {
        self.auth_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "username",
            |m: &LoginCredentials| { &m.username },
            |m: &mut LoginCredentials| { &mut m.username },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "typ",
            |m: &LoginCredentials| { &m.typ },
            |m: &mut LoginCredentials| { &mut m.typ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "auth_data",
            |m: &LoginCredentials| { &m.auth_data },
            |m: &mut LoginCredentials| { &mut m.auth_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoginCredentials>(
            "LoginCredentials",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoginCredentials {
    const NAME: &'static str = "LoginCredentials";

    fn is_initialized(&self) -> bool {
        if self.typ.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    self.username = ::std::option::Option::Some(is.read_string()?);
                },
                160 => {
                    self.typ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                242 => {
                    self.auth_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.username.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.typ {
            my_size += ::protobuf::rt::int32_size(20, v.value());
        }
        if let Some(v) = self.auth_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(30, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.username.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.typ {
            os.write_enum(20, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.auth_data.as_ref() {
            os.write_bytes(30, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoginCredentials {
        LoginCredentials::new()
    }

    fn clear(&mut self) {
        self.username = ::std::option::Option::None;
        self.typ = ::std::option::Option::None;
        self.auth_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoginCredentials {
        static instance: LoginCredentials = LoginCredentials {
            username: ::std::option::Option::None,
            typ: ::std::option::Option::None,
            auth_data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LoginCredentials {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoginCredentials").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoginCredentials {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoginCredentials {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:FingerprintResponseUnion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FingerprintResponseUnion {
    // message fields
    // @@protoc_insertion_point(field:FingerprintResponseUnion.grain)
    pub grain: ::protobuf::MessageField<FingerprintGrainResponse>,
    // @@protoc_insertion_point(field:FingerprintResponseUnion.hmac_ripemd)
    pub hmac_ripemd: ::protobuf::MessageField<FingerprintHmacRipemdResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:FingerprintResponseUnion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FingerprintResponseUnion {
    fn default() -> &'a FingerprintResponseUnion {
        <FingerprintResponseUnion as ::protobuf::Message>::default_instance()
    }
}

impl FingerprintResponseUnion {
    pub fn new() -> FingerprintResponseUnion {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FingerprintGrainResponse>(
            "grain",
            |m: &FingerprintResponseUnion| { &m.grain },
            |m: &mut FingerprintResponseUnion| { &mut m.grain },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FingerprintHmacRipemdResponse>(
            "hmac_ripemd",
            |m: &FingerprintResponseUnion| { &m.hmac_ripemd },
            |m: &mut FingerprintResponseUnion| { &mut m.hmac_ripemd },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FingerprintResponseUnion>(
            "FingerprintResponseUnion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FingerprintResponseUnion {
    const NAME: &'static str = "FingerprintResponseUnion";

    fn is_initialized(&self) -> bool {
        for v in &self.grain {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hmac_ripemd {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.grain)?;
                },
                162 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.hmac_ripemd)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.grain.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.hmac_ripemd.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.grain.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.hmac_ripemd.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FingerprintResponseUnion {
        FingerprintResponseUnion::new()
    }

    fn clear(&mut self) {
        self.grain.clear();
        self.hmac_ripemd.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FingerprintResponseUnion {
        static instance: FingerprintResponseUnion = FingerprintResponseUnion {
            grain: ::protobuf::MessageField::none(),
            hmac_ripemd: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FingerprintResponseUnion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FingerprintResponseUnion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FingerprintResponseUnion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FingerprintResponseUnion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:FingerprintGrainResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FingerprintGrainResponse {
    // message fields
    // @@protoc_insertion_point(field:FingerprintGrainResponse.encrypted_key)
    pub encrypted_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:FingerprintGrainResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FingerprintGrainResponse {
    fn default() -> &'a FingerprintGrainResponse {
        <FingerprintGrainResponse as ::protobuf::Message>::default_instance()
    }
}

impl FingerprintGrainResponse {
    pub fn new() -> FingerprintGrainResponse {
        ::std::default::Default::default()
    }

    // required bytes encrypted_key = 10;

    pub fn encrypted_key(&self) -> &[u8] {
        match self.encrypted_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_encrypted_key(&mut self) {
        self.encrypted_key = ::std::option::Option::None;
    }

    pub fn has_encrypted_key(&self) -> bool {
        self.encrypted_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encrypted_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.encrypted_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encrypted_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.encrypted_key.is_none() {
            self.encrypted_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.encrypted_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_encrypted_key(&mut self) -> ::std::vec::Vec<u8> {
        self.encrypted_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "encrypted_key",
            |m: &FingerprintGrainResponse| { &m.encrypted_key },
            |m: &mut FingerprintGrainResponse| { &mut m.encrypted_key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FingerprintGrainResponse>(
            "FingerprintGrainResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FingerprintGrainResponse {
    const NAME: &'static str = "FingerprintGrainResponse";

    fn is_initialized(&self) -> bool {
        if self.encrypted_key.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    self.encrypted_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.encrypted_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.encrypted_key.as_ref() {
            os.write_bytes(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FingerprintGrainResponse {
        FingerprintGrainResponse::new()
    }

    fn clear(&mut self) {
        self.encrypted_key = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FingerprintGrainResponse {
        static instance: FingerprintGrainResponse = FingerprintGrainResponse {
            encrypted_key: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FingerprintGrainResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FingerprintGrainResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FingerprintGrainResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FingerprintGrainResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:FingerprintHmacRipemdResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FingerprintHmacRipemdResponse {
    // message fields
    // @@protoc_insertion_point(field:FingerprintHmacRipemdResponse.hmac)
    pub hmac: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:FingerprintHmacRipemdResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FingerprintHmacRipemdResponse {
    fn default() -> &'a FingerprintHmacRipemdResponse {
        <FingerprintHmacRipemdResponse as ::protobuf::Message>::default_instance()
    }
}

impl FingerprintHmacRipemdResponse {
    pub fn new() -> FingerprintHmacRipemdResponse {
        ::std::default::Default::default()
    }

    // required bytes hmac = 10;

    pub fn hmac(&self) -> &[u8] {
        match self.hmac.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_hmac(&mut self) {
        self.hmac = ::std::option::Option::None;
    }

    pub fn has_hmac(&self) -> bool {
        self.hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.hmac = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.hmac.is_none() {
            self.hmac = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hmac",
            |m: &FingerprintHmacRipemdResponse| { &m.hmac },
            |m: &mut FingerprintHmacRipemdResponse| { &mut m.hmac },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FingerprintHmacRipemdResponse>(
            "FingerprintHmacRipemdResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FingerprintHmacRipemdResponse {
    const NAME: &'static str = "FingerprintHmacRipemdResponse";

    fn is_initialized(&self) -> bool {
        if self.hmac.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    self.hmac = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.hmac.as_ref() {
            os.write_bytes(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FingerprintHmacRipemdResponse {
        FingerprintHmacRipemdResponse::new()
    }

    fn clear(&mut self) {
        self.hmac = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FingerprintHmacRipemdResponse {
        static instance: FingerprintHmacRipemdResponse = FingerprintHmacRipemdResponse {
            hmac: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FingerprintHmacRipemdResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FingerprintHmacRipemdResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FingerprintHmacRipemdResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FingerprintHmacRipemdResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:PeerTicketUnion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PeerTicketUnion {
    // message fields
    // @@protoc_insertion_point(field:PeerTicketUnion.public_key)
    pub public_key: ::protobuf::MessageField<PeerTicketPublicKey>,
    // @@protoc_insertion_point(field:PeerTicketUnion.old_ticket)
    pub old_ticket: ::protobuf::MessageField<PeerTicketOld>,
    // special fields
    // @@protoc_insertion_point(special_field:PeerTicketUnion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PeerTicketUnion {
    fn default() -> &'a PeerTicketUnion {
        <PeerTicketUnion as ::protobuf::Message>::default_instance()
    }
}

impl PeerTicketUnion {
    pub fn new() -> PeerTicketUnion {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PeerTicketPublicKey>(
            "public_key",
            |m: &PeerTicketUnion| { &m.public_key },
            |m: &mut PeerTicketUnion| { &mut m.public_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PeerTicketOld>(
            "old_ticket",
            |m: &PeerTicketUnion| { &m.old_ticket },
            |m: &mut PeerTicketUnion| { &mut m.old_ticket },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PeerTicketUnion>(
            "PeerTicketUnion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PeerTicketUnion {
    const NAME: &'static str = "PeerTicketUnion";

    fn is_initialized(&self) -> bool {
        for v in &self.public_key {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.old_ticket {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.public_key)?;
                },
                162 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.old_ticket)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.public_key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.old_ticket.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.public_key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.old_ticket.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PeerTicketUnion {
        PeerTicketUnion::new()
    }

    fn clear(&mut self) {
        self.public_key.clear();
        self.old_ticket.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PeerTicketUnion {
        static instance: PeerTicketUnion = PeerTicketUnion {
            public_key: ::protobuf::MessageField::none(),
            old_ticket: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PeerTicketUnion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PeerTicketUnion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PeerTicketUnion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PeerTicketUnion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:PeerTicketPublicKey)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PeerTicketPublicKey {
    // message fields
    // @@protoc_insertion_point(field:PeerTicketPublicKey.public_key)
    pub public_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:PeerTicketPublicKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PeerTicketPublicKey {
    fn default() -> &'a PeerTicketPublicKey {
        <PeerTicketPublicKey as ::protobuf::Message>::default_instance()
    }
}

impl PeerTicketPublicKey {
    pub fn new() -> PeerTicketPublicKey {
        ::std::default::Default::default()
    }

    // required bytes public_key = 10;

    pub fn public_key(&self) -> &[u8] {
        match self.public_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_public_key(&mut self) {
        self.public_key = ::std::option::Option::None;
    }

    pub fn has_public_key(&self) -> bool {
        self.public_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.public_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.public_key.is_none() {
            self.public_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.public_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_public_key(&mut self) -> ::std::vec::Vec<u8> {
        self.public_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "public_key",
            |m: &PeerTicketPublicKey| { &m.public_key },
            |m: &mut PeerTicketPublicKey| { &mut m.public_key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PeerTicketPublicKey>(
            "PeerTicketPublicKey",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PeerTicketPublicKey {
    const NAME: &'static str = "PeerTicketPublicKey";

    fn is_initialized(&self) -> bool {
        if self.public_key.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    self.public_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.public_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.public_key.as_ref() {
            os.write_bytes(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PeerTicketPublicKey {
        PeerTicketPublicKey::new()
    }

    fn clear(&mut self) {
        self.public_key = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PeerTicketPublicKey {
        static instance: PeerTicketPublicKey = PeerTicketPublicKey {
            public_key: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PeerTicketPublicKey {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PeerTicketPublicKey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PeerTicketPublicKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PeerTicketPublicKey {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:PeerTicketOld)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PeerTicketOld {
    // message fields
    // @@protoc_insertion_point(field:PeerTicketOld.peer_ticket)
    pub peer_ticket: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:PeerTicketOld.peer_ticket_signature)
    pub peer_ticket_signature: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:PeerTicketOld.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PeerTicketOld {
    fn default() -> &'a PeerTicketOld {
        <PeerTicketOld as ::protobuf::Message>::default_instance()
    }
}

impl PeerTicketOld {
    pub fn new() -> PeerTicketOld {
        ::std::default::Default::default()
    }

    // required bytes peer_ticket = 10;

    pub fn peer_ticket(&self) -> &[u8] {
        match self.peer_ticket.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_peer_ticket(&mut self) {
        self.peer_ticket = ::std::option::Option::None;
    }

    pub fn has_peer_ticket(&self) -> bool {
        self.peer_ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peer_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.peer_ticket = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_peer_ticket(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.peer_ticket.is_none() {
            self.peer_ticket = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.peer_ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_peer_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.peer_ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes peer_ticket_signature = 20;

    pub fn peer_ticket_signature(&self) -> &[u8] {
        match self.peer_ticket_signature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_peer_ticket_signature(&mut self) {
        self.peer_ticket_signature = ::std::option::Option::None;
    }

    pub fn has_peer_ticket_signature(&self) -> bool {
        self.peer_ticket_signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peer_ticket_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.peer_ticket_signature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_peer_ticket_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.peer_ticket_signature.is_none() {
            self.peer_ticket_signature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.peer_ticket_signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_peer_ticket_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.peer_ticket_signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "peer_ticket",
            |m: &PeerTicketOld| { &m.peer_ticket },
            |m: &mut PeerTicketOld| { &mut m.peer_ticket },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "peer_ticket_signature",
            |m: &PeerTicketOld| { &m.peer_ticket_signature },
            |m: &mut PeerTicketOld| { &mut m.peer_ticket_signature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PeerTicketOld>(
            "PeerTicketOld",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PeerTicketOld {
    const NAME: &'static str = "PeerTicketOld";

    fn is_initialized(&self) -> bool {
        if self.peer_ticket.is_none() {
            return false;
        }
        if self.peer_ticket_signature.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    self.peer_ticket = ::std::option::Option::Some(is.read_bytes()?);
                },
                162 => {
                    self.peer_ticket_signature = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.peer_ticket.as_ref() {
            my_size += ::protobuf::rt::bytes_size(10, &v);
        }
        if let Some(v) = self.peer_ticket_signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(20, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.peer_ticket.as_ref() {
            os.write_bytes(10, v)?;
        }
        if let Some(v) = self.peer_ticket_signature.as_ref() {
            os.write_bytes(20, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PeerTicketOld {
        PeerTicketOld::new()
    }

    fn clear(&mut self) {
        self.peer_ticket = ::std::option::Option::None;
        self.peer_ticket_signature = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PeerTicketOld {
        static instance: PeerTicketOld = PeerTicketOld {
            peer_ticket: ::std::option::Option::None,
            peer_ticket_signature: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PeerTicketOld {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PeerTicketOld").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PeerTicketOld {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PeerTicketOld {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SystemInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SystemInfo {
    // message fields
    // @@protoc_insertion_point(field:SystemInfo.cpu_family)
    pub cpu_family: ::std::option::Option<::protobuf::EnumOrUnknown<CpuFamily>>,
    // @@protoc_insertion_point(field:SystemInfo.cpu_subtype)
    pub cpu_subtype: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SystemInfo.cpu_ext)
    pub cpu_ext: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SystemInfo.brand)
    pub brand: ::std::option::Option<::protobuf::EnumOrUnknown<Brand>>,
    // @@protoc_insertion_point(field:SystemInfo.brand_flags)
    pub brand_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SystemInfo.os)
    pub os: ::std::option::Option<::protobuf::EnumOrUnknown<Os>>,
    // @@protoc_insertion_point(field:SystemInfo.os_version)
    pub os_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SystemInfo.os_ext)
    pub os_ext: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SystemInfo.system_information_string)
    pub system_information_string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:SystemInfo.device_id)
    pub device_id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:SystemInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SystemInfo {
    fn default() -> &'a SystemInfo {
        <SystemInfo as ::protobuf::Message>::default_instance()
    }
}

impl SystemInfo {
    pub fn new() -> SystemInfo {
        ::std::default::Default::default()
    }

    // required .CpuFamily cpu_family = 10;

    pub fn cpu_family(&self) -> CpuFamily {
        match self.cpu_family {
            Some(e) => e.enum_value_or(CpuFamily::CPU_UNKNOWN),
            None => CpuFamily::CPU_UNKNOWN,
        }
    }

    pub fn clear_cpu_family(&mut self) {
        self.cpu_family = ::std::option::Option::None;
    }

    pub fn has_cpu_family(&self) -> bool {
        self.cpu_family.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_family(&mut self, v: CpuFamily) {
        self.cpu_family = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 cpu_subtype = 20;

    pub fn cpu_subtype(&self) -> u32 {
        self.cpu_subtype.unwrap_or(0)
    }

    pub fn clear_cpu_subtype(&mut self) {
        self.cpu_subtype = ::std::option::Option::None;
    }

    pub fn has_cpu_subtype(&self) -> bool {
        self.cpu_subtype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_subtype(&mut self, v: u32) {
        self.cpu_subtype = ::std::option::Option::Some(v);
    }

    // optional uint32 cpu_ext = 30;

    pub fn cpu_ext(&self) -> u32 {
        self.cpu_ext.unwrap_or(0)
    }

    pub fn clear_cpu_ext(&mut self) {
        self.cpu_ext = ::std::option::Option::None;
    }

    pub fn has_cpu_ext(&self) -> bool {
        self.cpu_ext.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_ext(&mut self, v: u32) {
        self.cpu_ext = ::std::option::Option::Some(v);
    }

    // optional .Brand brand = 40;

    pub fn brand(&self) -> Brand {
        match self.brand {
            Some(e) => e.enum_value_or(Brand::BRAND_UNBRANDED),
            None => Brand::BRAND_UNBRANDED,
        }
    }

    pub fn clear_brand(&mut self) {
        self.brand = ::std::option::Option::None;
    }

    pub fn has_brand(&self) -> bool {
        self.brand.is_some()
    }

    // Param is passed by value, moved
    pub fn set_brand(&mut self, v: Brand) {
        self.brand = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 brand_flags = 50;

    pub fn brand_flags(&self) -> u32 {
        self.brand_flags.unwrap_or(0)
    }

    pub fn clear_brand_flags(&mut self) {
        self.brand_flags = ::std::option::Option::None;
    }

    pub fn has_brand_flags(&self) -> bool {
        self.brand_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_brand_flags(&mut self, v: u32) {
        self.brand_flags = ::std::option::Option::Some(v);
    }

    // required .Os os = 60;

    pub fn os(&self) -> Os {
        match self.os {
            Some(e) => e.enum_value_or(Os::OS_UNKNOWN),
            None => Os::OS_UNKNOWN,
        }
    }

    pub fn clear_os(&mut self) {
        self.os = ::std::option::Option::None;
    }

    pub fn has_os(&self) -> bool {
        self.os.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os(&mut self, v: Os) {
        self.os = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 os_version = 70;

    pub fn os_version(&self) -> u32 {
        self.os_version.unwrap_or(0)
    }

    pub fn clear_os_version(&mut self) {
        self.os_version = ::std::option::Option::None;
    }

    pub fn has_os_version(&self) -> bool {
        self.os_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os_version(&mut self, v: u32) {
        self.os_version = ::std::option::Option::Some(v);
    }

    // optional uint32 os_ext = 80;

    pub fn os_ext(&self) -> u32 {
        self.os_ext.unwrap_or(0)
    }

    pub fn clear_os_ext(&mut self) {
        self.os_ext = ::std::option::Option::None;
    }

    pub fn has_os_ext(&self) -> bool {
        self.os_ext.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os_ext(&mut self, v: u32) {
        self.os_ext = ::std::option::Option::Some(v);
    }

    // optional string system_information_string = 90;

    pub fn system_information_string(&self) -> &str {
        match self.system_information_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_system_information_string(&mut self) {
        self.system_information_string = ::std::option::Option::None;
    }

    pub fn has_system_information_string(&self) -> bool {
        self.system_information_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system_information_string(&mut self, v: ::std::string::String) {
        self.system_information_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_system_information_string(&mut self) -> &mut ::std::string::String {
        if self.system_information_string.is_none() {
            self.system_information_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.system_information_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_system_information_string(&mut self) -> ::std::string::String {
        self.system_information_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string device_id = 100;

    pub fn device_id(&self) -> &str {
        match self.device_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_device_id(&mut self) {
        self.device_id = ::std::option::Option::None;
    }

    pub fn has_device_id(&self) -> bool {
        self.device_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_id(&mut self, v: ::std::string::String) {
        self.device_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_id(&mut self) -> &mut ::std::string::String {
        if self.device_id.is_none() {
            self.device_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.device_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_id(&mut self) -> ::std::string::String {
        self.device_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cpu_family",
            |m: &SystemInfo| { &m.cpu_family },
            |m: &mut SystemInfo| { &mut m.cpu_family },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cpu_subtype",
            |m: &SystemInfo| { &m.cpu_subtype },
            |m: &mut SystemInfo| { &mut m.cpu_subtype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cpu_ext",
            |m: &SystemInfo| { &m.cpu_ext },
            |m: &mut SystemInfo| { &mut m.cpu_ext },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "brand",
            |m: &SystemInfo| { &m.brand },
            |m: &mut SystemInfo| { &mut m.brand },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "brand_flags",
            |m: &SystemInfo| { &m.brand_flags },
            |m: &mut SystemInfo| { &mut m.brand_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "os",
            |m: &SystemInfo| { &m.os },
            |m: &mut SystemInfo| { &mut m.os },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "os_version",
            |m: &SystemInfo| { &m.os_version },
            |m: &mut SystemInfo| { &mut m.os_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "os_ext",
            |m: &SystemInfo| { &m.os_ext },
            |m: &mut SystemInfo| { &mut m.os_ext },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "system_information_string",
            |m: &SystemInfo| { &m.system_information_string },
            |m: &mut SystemInfo| { &mut m.system_information_string },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "device_id",
            |m: &SystemInfo| { &m.device_id },
            |m: &mut SystemInfo| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SystemInfo>(
            "SystemInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SystemInfo {
    const NAME: &'static str = "SystemInfo";

    fn is_initialized(&self) -> bool {
        if self.cpu_family.is_none() {
            return false;
        }
        if self.os.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                80 => {
                    self.cpu_family = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                160 => {
                    self.cpu_subtype = ::std::option::Option::Some(is.read_uint32()?);
                },
                240 => {
                    self.cpu_ext = ::std::option::Option::Some(is.read_uint32()?);
                },
                320 => {
                    self.brand = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                400 => {
                    self.brand_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                480 => {
                    self.os = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                560 => {
                    self.os_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                640 => {
                    self.os_ext = ::std::option::Option::Some(is.read_uint32()?);
                },
                722 => {
                    self.system_information_string = ::std::option::Option::Some(is.read_string()?);
                },
                802 => {
                    self.device_id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cpu_family {
            my_size += ::protobuf::rt::int32_size(10, v.value());
        }
        if let Some(v) = self.cpu_subtype {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.cpu_ext {
            my_size += ::protobuf::rt::uint32_size(30, v);
        }
        if let Some(v) = self.brand {
            my_size += ::protobuf::rt::int32_size(40, v.value());
        }
        if let Some(v) = self.brand_flags {
            my_size += ::protobuf::rt::uint32_size(50, v);
        }
        if let Some(v) = self.os {
            my_size += ::protobuf::rt::int32_size(60, v.value());
        }
        if let Some(v) = self.os_version {
            my_size += ::protobuf::rt::uint32_size(70, v);
        }
        if let Some(v) = self.os_ext {
            my_size += ::protobuf::rt::uint32_size(80, v);
        }
        if let Some(v) = self.system_information_string.as_ref() {
            my_size += ::protobuf::rt::string_size(90, &v);
        }
        if let Some(v) = self.device_id.as_ref() {
            my_size += ::protobuf::rt::string_size(100, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cpu_family {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.cpu_subtype {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.cpu_ext {
            os.write_uint32(30, v)?;
        }
        if let Some(v) = self.brand {
            os.write_enum(40, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.brand_flags {
            os.write_uint32(50, v)?;
        }
        if let Some(v) = self.os {
            os.write_enum(60, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.os_version {
            os.write_uint32(70, v)?;
        }
        if let Some(v) = self.os_ext {
            os.write_uint32(80, v)?;
        }
        if let Some(v) = self.system_information_string.as_ref() {
            os.write_string(90, v)?;
        }
        if let Some(v) = self.device_id.as_ref() {
            os.write_string(100, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SystemInfo {
        SystemInfo::new()
    }

    fn clear(&mut self) {
        self.cpu_family = ::std::option::Option::None;
        self.cpu_subtype = ::std::option::Option::None;
        self.cpu_ext = ::std::option::Option::None;
        self.brand = ::std::option::Option::None;
        self.brand_flags = ::std::option::Option::None;
        self.os = ::std::option::Option::None;
        self.os_version = ::std::option::Option::None;
        self.os_ext = ::std::option::Option::None;
        self.system_information_string = ::std::option::Option::None;
        self.device_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SystemInfo {
        static instance: SystemInfo = SystemInfo {
            cpu_family: ::std::option::Option::None,
            cpu_subtype: ::std::option::Option::None,
            cpu_ext: ::std::option::Option::None,
            brand: ::std::option::Option::None,
            brand_flags: ::std::option::Option::None,
            os: ::std::option::Option::None,
            os_version: ::std::option::Option::None,
            os_ext: ::std::option::Option::None,
            system_information_string: ::std::option::Option::None,
            device_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SystemInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SystemInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SystemInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SystemInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:LibspotifyAppKey)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LibspotifyAppKey {
    // message fields
    // @@protoc_insertion_point(field:LibspotifyAppKey.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:LibspotifyAppKey.devkey)
    pub devkey: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:LibspotifyAppKey.signature)
    pub signature: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:LibspotifyAppKey.useragent)
    pub useragent: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:LibspotifyAppKey.callback_hash)
    pub callback_hash: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:LibspotifyAppKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LibspotifyAppKey {
    fn default() -> &'a LibspotifyAppKey {
        <LibspotifyAppKey as ::protobuf::Message>::default_instance()
    }
}

impl LibspotifyAppKey {
    pub fn new() -> LibspotifyAppKey {
        ::std::default::Default::default()
    }

    // required uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // required bytes devkey = 2;

    pub fn devkey(&self) -> &[u8] {
        match self.devkey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_devkey(&mut self) {
        self.devkey = ::std::option::Option::None;
    }

    pub fn has_devkey(&self) -> bool {
        self.devkey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_devkey(&mut self, v: ::std::vec::Vec<u8>) {
        self.devkey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_devkey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.devkey.is_none() {
            self.devkey = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.devkey.as_mut().unwrap()
    }

    // Take field
    pub fn take_devkey(&mut self) -> ::std::vec::Vec<u8> {
        self.devkey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes signature = 3;

    pub fn signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_signature(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required string useragent = 4;

    pub fn useragent(&self) -> &str {
        match self.useragent.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_useragent(&mut self) {
        self.useragent = ::std::option::Option::None;
    }

    pub fn has_useragent(&self) -> bool {
        self.useragent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_useragent(&mut self, v: ::std::string::String) {
        self.useragent = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_useragent(&mut self) -> &mut ::std::string::String {
        if self.useragent.is_none() {
            self.useragent = ::std::option::Option::Some(::std::string::String::new());
        }
        self.useragent.as_mut().unwrap()
    }

    // Take field
    pub fn take_useragent(&mut self) -> ::std::string::String {
        self.useragent.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required bytes callback_hash = 5;

    pub fn callback_hash(&self) -> &[u8] {
        match self.callback_hash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_callback_hash(&mut self) {
        self.callback_hash = ::std::option::Option::None;
    }

    pub fn has_callback_hash(&self) -> bool {
        self.callback_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_callback_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.callback_hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_callback_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.callback_hash.is_none() {
            self.callback_hash = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.callback_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_callback_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.callback_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &LibspotifyAppKey| { &m.version },
            |m: &mut LibspotifyAppKey| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "devkey",
            |m: &LibspotifyAppKey| { &m.devkey },
            |m: &mut LibspotifyAppKey| { &mut m.devkey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "signature",
            |m: &LibspotifyAppKey| { &m.signature },
            |m: &mut LibspotifyAppKey| { &mut m.signature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "useragent",
            |m: &LibspotifyAppKey| { &m.useragent },
            |m: &mut LibspotifyAppKey| { &mut m.useragent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "callback_hash",
            |m: &LibspotifyAppKey| { &m.callback_hash },
            |m: &mut LibspotifyAppKey| { &mut m.callback_hash },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LibspotifyAppKey>(
            "LibspotifyAppKey",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LibspotifyAppKey {
    const NAME: &'static str = "LibspotifyAppKey";

    fn is_initialized(&self) -> bool {
        if self.version.is_none() {
            return false;
        }
        if self.devkey.is_none() {
            return false;
        }
        if self.signature.is_none() {
            return false;
        }
        if self.useragent.is_none() {
            return false;
        }
        if self.callback_hash.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.devkey = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.signature = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.useragent = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.callback_hash = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.devkey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.useragent.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.callback_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.devkey.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.signature.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.useragent.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.callback_hash.as_ref() {
            os.write_bytes(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LibspotifyAppKey {
        LibspotifyAppKey::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.devkey = ::std::option::Option::None;
        self.signature = ::std::option::Option::None;
        self.useragent = ::std::option::Option::None;
        self.callback_hash = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LibspotifyAppKey {
        static instance: LibspotifyAppKey = LibspotifyAppKey {
            version: ::std::option::Option::None,
            devkey: ::std::option::Option::None,
            signature: ::std::option::Option::None,
            useragent: ::std::option::Option::None,
            callback_hash: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LibspotifyAppKey {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LibspotifyAppKey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LibspotifyAppKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LibspotifyAppKey {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ClientInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ClientInfo {
    // message fields
    // @@protoc_insertion_point(field:ClientInfo.limited)
    pub limited: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ClientInfo.fb)
    pub fb: ::protobuf::MessageField<ClientInfoFacebook>,
    // @@protoc_insertion_point(field:ClientInfo.language)
    pub language: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ClientInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClientInfo {
    fn default() -> &'a ClientInfo {
        <ClientInfo as ::protobuf::Message>::default_instance()
    }
}

impl ClientInfo {
    pub fn new() -> ClientInfo {
        ::std::default::Default::default()
    }

    // optional bool limited = 1;

    pub fn limited(&self) -> bool {
        self.limited.unwrap_or(false)
    }

    pub fn clear_limited(&mut self) {
        self.limited = ::std::option::Option::None;
    }

    pub fn has_limited(&self) -> bool {
        self.limited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limited(&mut self, v: bool) {
        self.limited = ::std::option::Option::Some(v);
    }

    // optional string language = 3;

    pub fn language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language = ::std::option::Option::Some(::std::string::String::new());
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "limited",
            |m: &ClientInfo| { &m.limited },
            |m: &mut ClientInfo| { &mut m.limited },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ClientInfoFacebook>(
            "fb",
            |m: &ClientInfo| { &m.fb },
            |m: &mut ClientInfo| { &mut m.fb },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &ClientInfo| { &m.language },
            |m: &mut ClientInfo| { &mut m.language },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClientInfo>(
            "ClientInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClientInfo {
    const NAME: &'static str = "ClientInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.limited = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fb)?;
                },
                26 => {
                    self.language = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.limited {
            my_size += 1 + 1;
        }
        if let Some(v) = self.fb.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.limited {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.fb.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.language.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClientInfo {
        ClientInfo::new()
    }

    fn clear(&mut self) {
        self.limited = ::std::option::Option::None;
        self.fb.clear();
        self.language = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClientInfo {
        static instance: ClientInfo = ClientInfo {
            limited: ::std::option::Option::None,
            fb: ::protobuf::MessageField::none(),
            language: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClientInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClientInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClientInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ClientInfoFacebook)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ClientInfoFacebook {
    // message fields
    // @@protoc_insertion_point(field:ClientInfoFacebook.machine_id)
    pub machine_id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ClientInfoFacebook.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClientInfoFacebook {
    fn default() -> &'a ClientInfoFacebook {
        <ClientInfoFacebook as ::protobuf::Message>::default_instance()
    }
}

impl ClientInfoFacebook {
    pub fn new() -> ClientInfoFacebook {
        ::std::default::Default::default()
    }

    // optional string machine_id = 1;

    pub fn machine_id(&self) -> &str {
        match self.machine_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_machine_id(&mut self) {
        self.machine_id = ::std::option::Option::None;
    }

    pub fn has_machine_id(&self) -> bool {
        self.machine_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine_id(&mut self, v: ::std::string::String) {
        self.machine_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_id(&mut self) -> &mut ::std::string::String {
        if self.machine_id.is_none() {
            self.machine_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.machine_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine_id(&mut self) -> ::std::string::String {
        self.machine_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "machine_id",
            |m: &ClientInfoFacebook| { &m.machine_id },
            |m: &mut ClientInfoFacebook| { &mut m.machine_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClientInfoFacebook>(
            "ClientInfoFacebook",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClientInfoFacebook {
    const NAME: &'static str = "ClientInfoFacebook";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.machine_id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.machine_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.machine_id.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClientInfoFacebook {
        ClientInfoFacebook::new()
    }

    fn clear(&mut self) {
        self.machine_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClientInfoFacebook {
        static instance: ClientInfoFacebook = ClientInfoFacebook {
            machine_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClientInfoFacebook {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClientInfoFacebook").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClientInfoFacebook {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientInfoFacebook {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:APWelcome)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct APWelcome {
    // message fields
    // @@protoc_insertion_point(field:APWelcome.canonical_username)
    pub canonical_username: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:APWelcome.account_type_logged_in)
    pub account_type_logged_in: ::std::option::Option<::protobuf::EnumOrUnknown<AccountType>>,
    // @@protoc_insertion_point(field:APWelcome.credentials_type_logged_in)
    pub credentials_type_logged_in: ::std::option::Option<::protobuf::EnumOrUnknown<AccountType>>,
    // @@protoc_insertion_point(field:APWelcome.reusable_auth_credentials_type)
    pub reusable_auth_credentials_type: ::std::option::Option<::protobuf::EnumOrUnknown<AuthenticationType>>,
    // @@protoc_insertion_point(field:APWelcome.reusable_auth_credentials)
    pub reusable_auth_credentials: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:APWelcome.lfs_secret)
    pub lfs_secret: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:APWelcome.account_info)
    pub account_info: ::protobuf::MessageField<AccountInfo>,
    // @@protoc_insertion_point(field:APWelcome.fb)
    pub fb: ::protobuf::MessageField<AccountInfoFacebook>,
    // special fields
    // @@protoc_insertion_point(special_field:APWelcome.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a APWelcome {
    fn default() -> &'a APWelcome {
        <APWelcome as ::protobuf::Message>::default_instance()
    }
}

impl APWelcome {
    pub fn new() -> APWelcome {
        ::std::default::Default::default()
    }

    // required string canonical_username = 10;

    pub fn canonical_username(&self) -> &str {
        match self.canonical_username.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_canonical_username(&mut self) {
        self.canonical_username = ::std::option::Option::None;
    }

    pub fn has_canonical_username(&self) -> bool {
        self.canonical_username.is_some()
    }

    // Param is passed by value, moved
    pub fn set_canonical_username(&mut self, v: ::std::string::String) {
        self.canonical_username = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_canonical_username(&mut self) -> &mut ::std::string::String {
        if self.canonical_username.is_none() {
            self.canonical_username = ::std::option::Option::Some(::std::string::String::new());
        }
        self.canonical_username.as_mut().unwrap()
    }

    // Take field
    pub fn take_canonical_username(&mut self) -> ::std::string::String {
        self.canonical_username.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .AccountType account_type_logged_in = 20;

    pub fn account_type_logged_in(&self) -> AccountType {
        match self.account_type_logged_in {
            Some(e) => e.enum_value_or(AccountType::Spotify),
            None => AccountType::Spotify,
        }
    }

    pub fn clear_account_type_logged_in(&mut self) {
        self.account_type_logged_in = ::std::option::Option::None;
    }

    pub fn has_account_type_logged_in(&self) -> bool {
        self.account_type_logged_in.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_type_logged_in(&mut self, v: AccountType) {
        self.account_type_logged_in = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required .AccountType credentials_type_logged_in = 25;

    pub fn credentials_type_logged_in(&self) -> AccountType {
        match self.credentials_type_logged_in {
            Some(e) => e.enum_value_or(AccountType::Spotify),
            None => AccountType::Spotify,
        }
    }

    pub fn clear_credentials_type_logged_in(&mut self) {
        self.credentials_type_logged_in = ::std::option::Option::None;
    }

    pub fn has_credentials_type_logged_in(&self) -> bool {
        self.credentials_type_logged_in.is_some()
    }

    // Param is passed by value, moved
    pub fn set_credentials_type_logged_in(&mut self, v: AccountType) {
        self.credentials_type_logged_in = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required .AuthenticationType reusable_auth_credentials_type = 30;

    pub fn reusable_auth_credentials_type(&self) -> AuthenticationType {
        match self.reusable_auth_credentials_type {
            Some(e) => e.enum_value_or(AuthenticationType::AUTHENTICATION_USER_PASS),
            None => AuthenticationType::AUTHENTICATION_USER_PASS,
        }
    }

    pub fn clear_reusable_auth_credentials_type(&mut self) {
        self.reusable_auth_credentials_type = ::std::option::Option::None;
    }

    pub fn has_reusable_auth_credentials_type(&self) -> bool {
        self.reusable_auth_credentials_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reusable_auth_credentials_type(&mut self, v: AuthenticationType) {
        self.reusable_auth_credentials_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required bytes reusable_auth_credentials = 40;

    pub fn reusable_auth_credentials(&self) -> &[u8] {
        match self.reusable_auth_credentials.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_reusable_auth_credentials(&mut self) {
        self.reusable_auth_credentials = ::std::option::Option::None;
    }

    pub fn has_reusable_auth_credentials(&self) -> bool {
        self.reusable_auth_credentials.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reusable_auth_credentials(&mut self, v: ::std::vec::Vec<u8>) {
        self.reusable_auth_credentials = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reusable_auth_credentials(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.reusable_auth_credentials.is_none() {
            self.reusable_auth_credentials = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.reusable_auth_credentials.as_mut().unwrap()
    }

    // Take field
    pub fn take_reusable_auth_credentials(&mut self) -> ::std::vec::Vec<u8> {
        self.reusable_auth_credentials.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes lfs_secret = 50;

    pub fn lfs_secret(&self) -> &[u8] {
        match self.lfs_secret.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_lfs_secret(&mut self) {
        self.lfs_secret = ::std::option::Option::None;
    }

    pub fn has_lfs_secret(&self) -> bool {
        self.lfs_secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lfs_secret(&mut self, v: ::std::vec::Vec<u8>) {
        self.lfs_secret = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lfs_secret(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.lfs_secret.is_none() {
            self.lfs_secret = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.lfs_secret.as_mut().unwrap()
    }

    // Take field
    pub fn take_lfs_secret(&mut self) -> ::std::vec::Vec<u8> {
        self.lfs_secret.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "canonical_username",
            |m: &APWelcome| { &m.canonical_username },
            |m: &mut APWelcome| { &mut m.canonical_username },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_type_logged_in",
            |m: &APWelcome| { &m.account_type_logged_in },
            |m: &mut APWelcome| { &mut m.account_type_logged_in },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "credentials_type_logged_in",
            |m: &APWelcome| { &m.credentials_type_logged_in },
            |m: &mut APWelcome| { &mut m.credentials_type_logged_in },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reusable_auth_credentials_type",
            |m: &APWelcome| { &m.reusable_auth_credentials_type },
            |m: &mut APWelcome| { &mut m.reusable_auth_credentials_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reusable_auth_credentials",
            |m: &APWelcome| { &m.reusable_auth_credentials },
            |m: &mut APWelcome| { &mut m.reusable_auth_credentials },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lfs_secret",
            |m: &APWelcome| { &m.lfs_secret },
            |m: &mut APWelcome| { &mut m.lfs_secret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AccountInfo>(
            "account_info",
            |m: &APWelcome| { &m.account_info },
            |m: &mut APWelcome| { &mut m.account_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AccountInfoFacebook>(
            "fb",
            |m: &APWelcome| { &m.fb },
            |m: &mut APWelcome| { &mut m.fb },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<APWelcome>(
            "APWelcome",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for APWelcome {
    const NAME: &'static str = "APWelcome";

    fn is_initialized(&self) -> bool {
        if self.canonical_username.is_none() {
            return false;
        }
        if self.account_type_logged_in.is_none() {
            return false;
        }
        if self.credentials_type_logged_in.is_none() {
            return false;
        }
        if self.reusable_auth_credentials_type.is_none() {
            return false;
        }
        if self.reusable_auth_credentials.is_none() {
            return false;
        }
        for v in &self.account_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fb {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    self.canonical_username = ::std::option::Option::Some(is.read_string()?);
                },
                160 => {
                    self.account_type_logged_in = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                200 => {
                    self.credentials_type_logged_in = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                240 => {
                    self.reusable_auth_credentials_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                322 => {
                    self.reusable_auth_credentials = ::std::option::Option::Some(is.read_bytes()?);
                },
                402 => {
                    self.lfs_secret = ::std::option::Option::Some(is.read_bytes()?);
                },
                482 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.account_info)?;
                },
                562 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fb)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.canonical_username.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.account_type_logged_in {
            my_size += ::protobuf::rt::int32_size(20, v.value());
        }
        if let Some(v) = self.credentials_type_logged_in {
            my_size += ::protobuf::rt::int32_size(25, v.value());
        }
        if let Some(v) = self.reusable_auth_credentials_type {
            my_size += ::protobuf::rt::int32_size(30, v.value());
        }
        if let Some(v) = self.reusable_auth_credentials.as_ref() {
            my_size += ::protobuf::rt::bytes_size(40, &v);
        }
        if let Some(v) = self.lfs_secret.as_ref() {
            my_size += ::protobuf::rt::bytes_size(50, &v);
        }
        if let Some(v) = self.account_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.fb.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.canonical_username.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.account_type_logged_in {
            os.write_enum(20, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.credentials_type_logged_in {
            os.write_enum(25, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.reusable_auth_credentials_type {
            os.write_enum(30, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.reusable_auth_credentials.as_ref() {
            os.write_bytes(40, v)?;
        }
        if let Some(v) = self.lfs_secret.as_ref() {
            os.write_bytes(50, v)?;
        }
        if let Some(v) = self.account_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(60, v, os)?;
        }
        if let Some(v) = self.fb.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(70, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> APWelcome {
        APWelcome::new()
    }

    fn clear(&mut self) {
        self.canonical_username = ::std::option::Option::None;
        self.account_type_logged_in = ::std::option::Option::None;
        self.credentials_type_logged_in = ::std::option::Option::None;
        self.reusable_auth_credentials_type = ::std::option::Option::None;
        self.reusable_auth_credentials = ::std::option::Option::None;
        self.lfs_secret = ::std::option::Option::None;
        self.account_info.clear();
        self.fb.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static APWelcome {
        static instance: APWelcome = APWelcome {
            canonical_username: ::std::option::Option::None,
            account_type_logged_in: ::std::option::Option::None,
            credentials_type_logged_in: ::std::option::Option::None,
            reusable_auth_credentials_type: ::std::option::Option::None,
            reusable_auth_credentials: ::std::option::Option::None,
            lfs_secret: ::std::option::Option::None,
            account_info: ::protobuf::MessageField::none(),
            fb: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for APWelcome {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("APWelcome").unwrap()).clone()
    }
}

impl ::std::fmt::Display for APWelcome {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for APWelcome {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:AccountInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AccountInfo {
    // message fields
    // @@protoc_insertion_point(field:AccountInfo.spotify)
    pub spotify: ::protobuf::MessageField<AccountInfoSpotify>,
    // @@protoc_insertion_point(field:AccountInfo.facebook)
    pub facebook: ::protobuf::MessageField<AccountInfoFacebook>,
    // special fields
    // @@protoc_insertion_point(special_field:AccountInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AccountInfo {
    fn default() -> &'a AccountInfo {
        <AccountInfo as ::protobuf::Message>::default_instance()
    }
}

impl AccountInfo {
    pub fn new() -> AccountInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AccountInfoSpotify>(
            "spotify",
            |m: &AccountInfo| { &m.spotify },
            |m: &mut AccountInfo| { &mut m.spotify },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AccountInfoFacebook>(
            "facebook",
            |m: &AccountInfo| { &m.facebook },
            |m: &mut AccountInfo| { &mut m.facebook },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AccountInfo>(
            "AccountInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AccountInfo {
    const NAME: &'static str = "AccountInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spotify)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.facebook)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.spotify.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.facebook.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.spotify.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.facebook.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AccountInfo {
        AccountInfo::new()
    }

    fn clear(&mut self) {
        self.spotify.clear();
        self.facebook.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AccountInfo {
        static instance: AccountInfo = AccountInfo {
            spotify: ::protobuf::MessageField::none(),
            facebook: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AccountInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AccountInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AccountInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:AccountInfoSpotify)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AccountInfoSpotify {
    // special fields
    // @@protoc_insertion_point(special_field:AccountInfoSpotify.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AccountInfoSpotify {
    fn default() -> &'a AccountInfoSpotify {
        <AccountInfoSpotify as ::protobuf::Message>::default_instance()
    }
}

impl AccountInfoSpotify {
    pub fn new() -> AccountInfoSpotify {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AccountInfoSpotify>(
            "AccountInfoSpotify",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AccountInfoSpotify {
    const NAME: &'static str = "AccountInfoSpotify";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AccountInfoSpotify {
        AccountInfoSpotify::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AccountInfoSpotify {
        static instance: AccountInfoSpotify = AccountInfoSpotify {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AccountInfoSpotify {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AccountInfoSpotify").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AccountInfoSpotify {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountInfoSpotify {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:AccountInfoFacebook)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AccountInfoFacebook {
    // message fields
    // @@protoc_insertion_point(field:AccountInfoFacebook.access_token)
    pub access_token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:AccountInfoFacebook.machine_id)
    pub machine_id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:AccountInfoFacebook.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AccountInfoFacebook {
    fn default() -> &'a AccountInfoFacebook {
        <AccountInfoFacebook as ::protobuf::Message>::default_instance()
    }
}

impl AccountInfoFacebook {
    pub fn new() -> AccountInfoFacebook {
        ::std::default::Default::default()
    }

    // optional string access_token = 1;

    pub fn access_token(&self) -> &str {
        match self.access_token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_access_token(&mut self) {
        self.access_token = ::std::option::Option::None;
    }

    pub fn has_access_token(&self) -> bool {
        self.access_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_access_token(&mut self, v: ::std::string::String) {
        self.access_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_access_token(&mut self) -> &mut ::std::string::String {
        if self.access_token.is_none() {
            self.access_token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.access_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_access_token(&mut self) -> ::std::string::String {
        self.access_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string machine_id = 2;

    pub fn machine_id(&self) -> &str {
        match self.machine_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_machine_id(&mut self) {
        self.machine_id = ::std::option::Option::None;
    }

    pub fn has_machine_id(&self) -> bool {
        self.machine_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine_id(&mut self, v: ::std::string::String) {
        self.machine_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_id(&mut self) -> &mut ::std::string::String {
        if self.machine_id.is_none() {
            self.machine_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.machine_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine_id(&mut self) -> ::std::string::String {
        self.machine_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "access_token",
            |m: &AccountInfoFacebook| { &m.access_token },
            |m: &mut AccountInfoFacebook| { &mut m.access_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "machine_id",
            |m: &AccountInfoFacebook| { &m.machine_id },
            |m: &mut AccountInfoFacebook| { &mut m.machine_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AccountInfoFacebook>(
            "AccountInfoFacebook",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AccountInfoFacebook {
    const NAME: &'static str = "AccountInfoFacebook";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.access_token = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.machine_id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.access_token.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.machine_id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.access_token.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.machine_id.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AccountInfoFacebook {
        AccountInfoFacebook::new()
    }

    fn clear(&mut self) {
        self.access_token = ::std::option::Option::None;
        self.machine_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AccountInfoFacebook {
        static instance: AccountInfoFacebook = AccountInfoFacebook {
            access_token: ::std::option::Option::None,
            machine_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AccountInfoFacebook {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AccountInfoFacebook").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AccountInfoFacebook {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountInfoFacebook {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:AuthenticationType)
pub enum AuthenticationType {
    // @@protoc_insertion_point(enum_value:AuthenticationType.AUTHENTICATION_USER_PASS)
    AUTHENTICATION_USER_PASS = 0,
    // @@protoc_insertion_point(enum_value:AuthenticationType.AUTHENTICATION_STORED_SPOTIFY_CREDENTIALS)
    AUTHENTICATION_STORED_SPOTIFY_CREDENTIALS = 1,
    // @@protoc_insertion_point(enum_value:AuthenticationType.AUTHENTICATION_STORED_FACEBOOK_CREDENTIALS)
    AUTHENTICATION_STORED_FACEBOOK_CREDENTIALS = 2,
    // @@protoc_insertion_point(enum_value:AuthenticationType.AUTHENTICATION_SPOTIFY_TOKEN)
    AUTHENTICATION_SPOTIFY_TOKEN = 3,
    // @@protoc_insertion_point(enum_value:AuthenticationType.AUTHENTICATION_FACEBOOK_TOKEN)
    AUTHENTICATION_FACEBOOK_TOKEN = 4,
}

impl ::protobuf::Enum for AuthenticationType {
    const NAME: &'static str = "AuthenticationType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AuthenticationType> {
        match value {
            0 => ::std::option::Option::Some(AuthenticationType::AUTHENTICATION_USER_PASS),
            1 => ::std::option::Option::Some(AuthenticationType::AUTHENTICATION_STORED_SPOTIFY_CREDENTIALS),
            2 => ::std::option::Option::Some(AuthenticationType::AUTHENTICATION_STORED_FACEBOOK_CREDENTIALS),
            3 => ::std::option::Option::Some(AuthenticationType::AUTHENTICATION_SPOTIFY_TOKEN),
            4 => ::std::option::Option::Some(AuthenticationType::AUTHENTICATION_FACEBOOK_TOKEN),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<AuthenticationType> {
        match str {
            "AUTHENTICATION_USER_PASS" => ::std::option::Option::Some(AuthenticationType::AUTHENTICATION_USER_PASS),
            "AUTHENTICATION_STORED_SPOTIFY_CREDENTIALS" => ::std::option::Option::Some(AuthenticationType::AUTHENTICATION_STORED_SPOTIFY_CREDENTIALS),
            "AUTHENTICATION_STORED_FACEBOOK_CREDENTIALS" => ::std::option::Option::Some(AuthenticationType::AUTHENTICATION_STORED_FACEBOOK_CREDENTIALS),
            "AUTHENTICATION_SPOTIFY_TOKEN" => ::std::option::Option::Some(AuthenticationType::AUTHENTICATION_SPOTIFY_TOKEN),
            "AUTHENTICATION_FACEBOOK_TOKEN" => ::std::option::Option::Some(AuthenticationType::AUTHENTICATION_FACEBOOK_TOKEN),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AuthenticationType] = &[
        AuthenticationType::AUTHENTICATION_USER_PASS,
        AuthenticationType::AUTHENTICATION_STORED_SPOTIFY_CREDENTIALS,
        AuthenticationType::AUTHENTICATION_STORED_FACEBOOK_CREDENTIALS,
        AuthenticationType::AUTHENTICATION_SPOTIFY_TOKEN,
        AuthenticationType::AUTHENTICATION_FACEBOOK_TOKEN,
    ];
}

impl ::protobuf::EnumFull for AuthenticationType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("AuthenticationType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for AuthenticationType {
    fn default() -> Self {
        AuthenticationType::AUTHENTICATION_USER_PASS
    }
}

impl AuthenticationType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<AuthenticationType>("AuthenticationType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:AccountCreation)
pub enum AccountCreation {
    // @@protoc_insertion_point(enum_value:AccountCreation.ACCOUNT_CREATION_ALWAYS_PROMPT)
    ACCOUNT_CREATION_ALWAYS_PROMPT = 1,
    // @@protoc_insertion_point(enum_value:AccountCreation.ACCOUNT_CREATION_ALWAYS_CREATE)
    ACCOUNT_CREATION_ALWAYS_CREATE = 3,
}

impl ::protobuf::Enum for AccountCreation {
    const NAME: &'static str = "AccountCreation";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AccountCreation> {
        match value {
            1 => ::std::option::Option::Some(AccountCreation::ACCOUNT_CREATION_ALWAYS_PROMPT),
            3 => ::std::option::Option::Some(AccountCreation::ACCOUNT_CREATION_ALWAYS_CREATE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<AccountCreation> {
        match str {
            "ACCOUNT_CREATION_ALWAYS_PROMPT" => ::std::option::Option::Some(AccountCreation::ACCOUNT_CREATION_ALWAYS_PROMPT),
            "ACCOUNT_CREATION_ALWAYS_CREATE" => ::std::option::Option::Some(AccountCreation::ACCOUNT_CREATION_ALWAYS_CREATE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AccountCreation] = &[
        AccountCreation::ACCOUNT_CREATION_ALWAYS_PROMPT,
        AccountCreation::ACCOUNT_CREATION_ALWAYS_CREATE,
    ];
}

impl ::protobuf::EnumFull for AccountCreation {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("AccountCreation").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            AccountCreation::ACCOUNT_CREATION_ALWAYS_PROMPT => 0,
            AccountCreation::ACCOUNT_CREATION_ALWAYS_CREATE => 1,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for AccountCreation {
    fn default() -> Self {
        AccountCreation::ACCOUNT_CREATION_ALWAYS_PROMPT
    }
}

impl AccountCreation {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<AccountCreation>("AccountCreation")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:CpuFamily)
pub enum CpuFamily {
    // @@protoc_insertion_point(enum_value:CpuFamily.CPU_UNKNOWN)
    CPU_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:CpuFamily.CPU_X86)
    CPU_X86 = 1,
    // @@protoc_insertion_point(enum_value:CpuFamily.CPU_X86_64)
    CPU_X86_64 = 2,
    // @@protoc_insertion_point(enum_value:CpuFamily.CPU_PPC)
    CPU_PPC = 3,
    // @@protoc_insertion_point(enum_value:CpuFamily.CPU_PPC_64)
    CPU_PPC_64 = 4,
    // @@protoc_insertion_point(enum_value:CpuFamily.CPU_ARM)
    CPU_ARM = 5,
    // @@protoc_insertion_point(enum_value:CpuFamily.CPU_IA64)
    CPU_IA64 = 6,
    // @@protoc_insertion_point(enum_value:CpuFamily.CPU_SH)
    CPU_SH = 7,
    // @@protoc_insertion_point(enum_value:CpuFamily.CPU_MIPS)
    CPU_MIPS = 8,
    // @@protoc_insertion_point(enum_value:CpuFamily.CPU_BLACKFIN)
    CPU_BLACKFIN = 9,
}

impl ::protobuf::Enum for CpuFamily {
    const NAME: &'static str = "CpuFamily";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CpuFamily> {
        match value {
            0 => ::std::option::Option::Some(CpuFamily::CPU_UNKNOWN),
            1 => ::std::option::Option::Some(CpuFamily::CPU_X86),
            2 => ::std::option::Option::Some(CpuFamily::CPU_X86_64),
            3 => ::std::option::Option::Some(CpuFamily::CPU_PPC),
            4 => ::std::option::Option::Some(CpuFamily::CPU_PPC_64),
            5 => ::std::option::Option::Some(CpuFamily::CPU_ARM),
            6 => ::std::option::Option::Some(CpuFamily::CPU_IA64),
            7 => ::std::option::Option::Some(CpuFamily::CPU_SH),
            8 => ::std::option::Option::Some(CpuFamily::CPU_MIPS),
            9 => ::std::option::Option::Some(CpuFamily::CPU_BLACKFIN),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CpuFamily> {
        match str {
            "CPU_UNKNOWN" => ::std::option::Option::Some(CpuFamily::CPU_UNKNOWN),
            "CPU_X86" => ::std::option::Option::Some(CpuFamily::CPU_X86),
            "CPU_X86_64" => ::std::option::Option::Some(CpuFamily::CPU_X86_64),
            "CPU_PPC" => ::std::option::Option::Some(CpuFamily::CPU_PPC),
            "CPU_PPC_64" => ::std::option::Option::Some(CpuFamily::CPU_PPC_64),
            "CPU_ARM" => ::std::option::Option::Some(CpuFamily::CPU_ARM),
            "CPU_IA64" => ::std::option::Option::Some(CpuFamily::CPU_IA64),
            "CPU_SH" => ::std::option::Option::Some(CpuFamily::CPU_SH),
            "CPU_MIPS" => ::std::option::Option::Some(CpuFamily::CPU_MIPS),
            "CPU_BLACKFIN" => ::std::option::Option::Some(CpuFamily::CPU_BLACKFIN),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CpuFamily] = &[
        CpuFamily::CPU_UNKNOWN,
        CpuFamily::CPU_X86,
        CpuFamily::CPU_X86_64,
        CpuFamily::CPU_PPC,
        CpuFamily::CPU_PPC_64,
        CpuFamily::CPU_ARM,
        CpuFamily::CPU_IA64,
        CpuFamily::CPU_SH,
        CpuFamily::CPU_MIPS,
        CpuFamily::CPU_BLACKFIN,
    ];
}

impl ::protobuf::EnumFull for CpuFamily {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CpuFamily").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for CpuFamily {
    fn default() -> Self {
        CpuFamily::CPU_UNKNOWN
    }
}

impl CpuFamily {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CpuFamily>("CpuFamily")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:Brand)
pub enum Brand {
    // @@protoc_insertion_point(enum_value:Brand.BRAND_UNBRANDED)
    BRAND_UNBRANDED = 0,
    // @@protoc_insertion_point(enum_value:Brand.BRAND_INQ)
    BRAND_INQ = 1,
    // @@protoc_insertion_point(enum_value:Brand.BRAND_HTC)
    BRAND_HTC = 2,
    // @@protoc_insertion_point(enum_value:Brand.BRAND_NOKIA)
    BRAND_NOKIA = 3,
}

impl ::protobuf::Enum for Brand {
    const NAME: &'static str = "Brand";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Brand> {
        match value {
            0 => ::std::option::Option::Some(Brand::BRAND_UNBRANDED),
            1 => ::std::option::Option::Some(Brand::BRAND_INQ),
            2 => ::std::option::Option::Some(Brand::BRAND_HTC),
            3 => ::std::option::Option::Some(Brand::BRAND_NOKIA),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Brand> {
        match str {
            "BRAND_UNBRANDED" => ::std::option::Option::Some(Brand::BRAND_UNBRANDED),
            "BRAND_INQ" => ::std::option::Option::Some(Brand::BRAND_INQ),
            "BRAND_HTC" => ::std::option::Option::Some(Brand::BRAND_HTC),
            "BRAND_NOKIA" => ::std::option::Option::Some(Brand::BRAND_NOKIA),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Brand] = &[
        Brand::BRAND_UNBRANDED,
        Brand::BRAND_INQ,
        Brand::BRAND_HTC,
        Brand::BRAND_NOKIA,
    ];
}

impl ::protobuf::EnumFull for Brand {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Brand").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Brand {
    fn default() -> Self {
        Brand::BRAND_UNBRANDED
    }
}

impl Brand {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Brand>("Brand")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:Os)
pub enum Os {
    // @@protoc_insertion_point(enum_value:Os.OS_UNKNOWN)
    OS_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:Os.OS_WINDOWS)
    OS_WINDOWS = 1,
    // @@protoc_insertion_point(enum_value:Os.OS_OSX)
    OS_OSX = 2,
    // @@protoc_insertion_point(enum_value:Os.OS_IPHONE)
    OS_IPHONE = 3,
    // @@protoc_insertion_point(enum_value:Os.OS_S60)
    OS_S60 = 4,
    // @@protoc_insertion_point(enum_value:Os.OS_LINUX)
    OS_LINUX = 5,
    // @@protoc_insertion_point(enum_value:Os.OS_WINDOWS_CE)
    OS_WINDOWS_CE = 6,
    // @@protoc_insertion_point(enum_value:Os.OS_ANDROID)
    OS_ANDROID = 7,
    // @@protoc_insertion_point(enum_value:Os.OS_PALM)
    OS_PALM = 8,
    // @@protoc_insertion_point(enum_value:Os.OS_FREEBSD)
    OS_FREEBSD = 9,
    // @@protoc_insertion_point(enum_value:Os.OS_BLACKBERRY)
    OS_BLACKBERRY = 10,
    // @@protoc_insertion_point(enum_value:Os.OS_SONOS)
    OS_SONOS = 11,
    // @@protoc_insertion_point(enum_value:Os.OS_LOGITECH)
    OS_LOGITECH = 12,
    // @@protoc_insertion_point(enum_value:Os.OS_WP7)
    OS_WP7 = 13,
    // @@protoc_insertion_point(enum_value:Os.OS_ONKYO)
    OS_ONKYO = 14,
    // @@protoc_insertion_point(enum_value:Os.OS_PHILIPS)
    OS_PHILIPS = 15,
    // @@protoc_insertion_point(enum_value:Os.OS_WD)
    OS_WD = 16,
    // @@protoc_insertion_point(enum_value:Os.OS_VOLVO)
    OS_VOLVO = 17,
    // @@protoc_insertion_point(enum_value:Os.OS_TIVO)
    OS_TIVO = 18,
    // @@protoc_insertion_point(enum_value:Os.OS_AWOX)
    OS_AWOX = 19,
    // @@protoc_insertion_point(enum_value:Os.OS_MEEGO)
    OS_MEEGO = 20,
    // @@protoc_insertion_point(enum_value:Os.OS_QNXNTO)
    OS_QNXNTO = 21,
    // @@protoc_insertion_point(enum_value:Os.OS_BCO)
    OS_BCO = 22,
}

impl ::protobuf::Enum for Os {
    const NAME: &'static str = "Os";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Os> {
        match value {
            0 => ::std::option::Option::Some(Os::OS_UNKNOWN),
            1 => ::std::option::Option::Some(Os::OS_WINDOWS),
            2 => ::std::option::Option::Some(Os::OS_OSX),
            3 => ::std::option::Option::Some(Os::OS_IPHONE),
            4 => ::std::option::Option::Some(Os::OS_S60),
            5 => ::std::option::Option::Some(Os::OS_LINUX),
            6 => ::std::option::Option::Some(Os::OS_WINDOWS_CE),
            7 => ::std::option::Option::Some(Os::OS_ANDROID),
            8 => ::std::option::Option::Some(Os::OS_PALM),
            9 => ::std::option::Option::Some(Os::OS_FREEBSD),
            10 => ::std::option::Option::Some(Os::OS_BLACKBERRY),
            11 => ::std::option::Option::Some(Os::OS_SONOS),
            12 => ::std::option::Option::Some(Os::OS_LOGITECH),
            13 => ::std::option::Option::Some(Os::OS_WP7),
            14 => ::std::option::Option::Some(Os::OS_ONKYO),
            15 => ::std::option::Option::Some(Os::OS_PHILIPS),
            16 => ::std::option::Option::Some(Os::OS_WD),
            17 => ::std::option::Option::Some(Os::OS_VOLVO),
            18 => ::std::option::Option::Some(Os::OS_TIVO),
            19 => ::std::option::Option::Some(Os::OS_AWOX),
            20 => ::std::option::Option::Some(Os::OS_MEEGO),
            21 => ::std::option::Option::Some(Os::OS_QNXNTO),
            22 => ::std::option::Option::Some(Os::OS_BCO),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Os> {
        match str {
            "OS_UNKNOWN" => ::std::option::Option::Some(Os::OS_UNKNOWN),
            "OS_WINDOWS" => ::std::option::Option::Some(Os::OS_WINDOWS),
            "OS_OSX" => ::std::option::Option::Some(Os::OS_OSX),
            "OS_IPHONE" => ::std::option::Option::Some(Os::OS_IPHONE),
            "OS_S60" => ::std::option::Option::Some(Os::OS_S60),
            "OS_LINUX" => ::std::option::Option::Some(Os::OS_LINUX),
            "OS_WINDOWS_CE" => ::std::option::Option::Some(Os::OS_WINDOWS_CE),
            "OS_ANDROID" => ::std::option::Option::Some(Os::OS_ANDROID),
            "OS_PALM" => ::std::option::Option::Some(Os::OS_PALM),
            "OS_FREEBSD" => ::std::option::Option::Some(Os::OS_FREEBSD),
            "OS_BLACKBERRY" => ::std::option::Option::Some(Os::OS_BLACKBERRY),
            "OS_SONOS" => ::std::option::Option::Some(Os::OS_SONOS),
            "OS_LOGITECH" => ::std::option::Option::Some(Os::OS_LOGITECH),
            "OS_WP7" => ::std::option::Option::Some(Os::OS_WP7),
            "OS_ONKYO" => ::std::option::Option::Some(Os::OS_ONKYO),
            "OS_PHILIPS" => ::std::option::Option::Some(Os::OS_PHILIPS),
            "OS_WD" => ::std::option::Option::Some(Os::OS_WD),
            "OS_VOLVO" => ::std::option::Option::Some(Os::OS_VOLVO),
            "OS_TIVO" => ::std::option::Option::Some(Os::OS_TIVO),
            "OS_AWOX" => ::std::option::Option::Some(Os::OS_AWOX),
            "OS_MEEGO" => ::std::option::Option::Some(Os::OS_MEEGO),
            "OS_QNXNTO" => ::std::option::Option::Some(Os::OS_QNXNTO),
            "OS_BCO" => ::std::option::Option::Some(Os::OS_BCO),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Os] = &[
        Os::OS_UNKNOWN,
        Os::OS_WINDOWS,
        Os::OS_OSX,
        Os::OS_IPHONE,
        Os::OS_S60,
        Os::OS_LINUX,
        Os::OS_WINDOWS_CE,
        Os::OS_ANDROID,
        Os::OS_PALM,
        Os::OS_FREEBSD,
        Os::OS_BLACKBERRY,
        Os::OS_SONOS,
        Os::OS_LOGITECH,
        Os::OS_WP7,
        Os::OS_ONKYO,
        Os::OS_PHILIPS,
        Os::OS_WD,
        Os::OS_VOLVO,
        Os::OS_TIVO,
        Os::OS_AWOX,
        Os::OS_MEEGO,
        Os::OS_QNXNTO,
        Os::OS_BCO,
    ];
}

impl ::protobuf::EnumFull for Os {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Os").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Os {
    fn default() -> Self {
        Os::OS_UNKNOWN
    }
}

impl Os {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Os>("Os")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:AccountType)
pub enum AccountType {
    // @@protoc_insertion_point(enum_value:AccountType.Spotify)
    Spotify = 0,
    // @@protoc_insertion_point(enum_value:AccountType.Facebook)
    Facebook = 1,
}

impl ::protobuf::Enum for AccountType {
    const NAME: &'static str = "AccountType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AccountType> {
        match value {
            0 => ::std::option::Option::Some(AccountType::Spotify),
            1 => ::std::option::Option::Some(AccountType::Facebook),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<AccountType> {
        match str {
            "Spotify" => ::std::option::Option::Some(AccountType::Spotify),
            "Facebook" => ::std::option::Option::Some(AccountType::Facebook),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AccountType] = &[
        AccountType::Spotify,
        AccountType::Facebook,
    ];
}

impl ::protobuf::EnumFull for AccountType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("AccountType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for AccountType {
    fn default() -> Self {
        AccountType::Spotify
    }
}

impl AccountType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<AccountType>("AccountType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x14authentication.proto\"\xec\x03\n\x17ClientResponseEncrypted\x12>\n\
    \x11login_credentials\x18\n\x20\x02(\x0b2\x11.LoginCredentialsR\x10login\
    Credentials\x12;\n\x10account_creation\x18\x14\x20\x01(\x0e2\x10.Account\
    CreationR\x0faccountCreation\x12L\n\x14fingerprint_response\x18\x1e\x20\
    \x01(\x0b2\x19.FingerprintResponseUnionR\x13fingerprintResponse\x121\n\
    \x0bpeer_ticket\x18(\x20\x01(\x0b2\x10.PeerTicketUnionR\npeerTicket\x12,\
    \n\x0bsystem_info\x182\x20\x02(\x0b2\x0b.SystemInfoR\nsystemInfo\x12%\n\
    \x0eplatform_model\x18<\x20\x01(\tR\rplatformModel\x12%\n\x0eversion_str\
    ing\x18F\x20\x01(\tR\rversionString\x12)\n\x06appkey\x18P\x20\x01(\x0b2\
    \x11.LibspotifyAppKeyR\x06appkey\x12,\n\x0bclient_info\x18Z\x20\x01(\x0b\
    2\x0b.ClientInfoR\nclientInfo\"r\n\x10LoginCredentials\x12\x1a\n\x08user\
    name\x18\n\x20\x01(\tR\x08username\x12%\n\x03typ\x18\x14\x20\x02(\x0e2\
    \x13.AuthenticationTypeR\x03typ\x12\x1b\n\tauth_data\x18\x1e\x20\x01(\
    \x0cR\x08authData\"\x8c\x01\n\x18FingerprintResponseUnion\x12/\n\x05grai\
    n\x18\n\x20\x01(\x0b2\x19.FingerprintGrainResponseR\x05grain\x12?\n\x0bh\
    mac_ripemd\x18\x14\x20\x01(\x0b2\x1e.FingerprintHmacRipemdResponseR\nhma\
    cRipemd\"?\n\x18FingerprintGrainResponse\x12#\n\rencrypted_key\x18\n\x20\
    \x02(\x0cR\x0cencryptedKey\"3\n\x1dFingerprintHmacRipemdResponse\x12\x12\
    \n\x04hmac\x18\n\x20\x02(\x0cR\x04hmac\"u\n\x0fPeerTicketUnion\x123\n\np\
    ublic_key\x18\n\x20\x01(\x0b2\x14.PeerTicketPublicKeyR\tpublicKey\x12-\n\
    \nold_ticket\x18\x14\x20\x01(\x0b2\x0e.PeerTicketOldR\toldTicket\"4\n\
    \x13PeerTicketPublicKey\x12\x1d\n\npublic_key\x18\n\x20\x02(\x0cR\tpubli\
    cKey\"d\n\rPeerTicketOld\x12\x1f\n\x0bpeer_ticket\x18\n\x20\x02(\x0cR\np\
    eerTicket\x122\n\x15peer_ticket_signature\x18\x14\x20\x02(\x0cR\x13peerT\
    icketSignature\"\xd4\x02\n\nSystemInfo\x12)\n\ncpu_family\x18\n\x20\x02(\
    \x0e2\n.CpuFamilyR\tcpuFamily\x12\x1f\n\x0bcpu_subtype\x18\x14\x20\x01(\
    \rR\ncpuSubtype\x12\x17\n\x07cpu_ext\x18\x1e\x20\x01(\rR\x06cpuExt\x12\
    \x1c\n\x05brand\x18(\x20\x01(\x0e2\x06.BrandR\x05brand\x12\x1f\n\x0bbran\
    d_flags\x182\x20\x01(\rR\nbrandFlags\x12\x13\n\x02os\x18<\x20\x02(\x0e2\
    \x03.OsR\x02os\x12\x1d\n\nos_version\x18F\x20\x01(\rR\tosVersion\x12\x15\
    \n\x06os_ext\x18P\x20\x01(\rR\x05osExt\x12:\n\x19system_information_stri\
    ng\x18Z\x20\x01(\tR\x17systemInformationString\x12\x1b\n\tdevice_id\x18d\
    \x20\x01(\tR\x08deviceId\"\xa5\x01\n\x10LibspotifyAppKey\x12\x18\n\x07ve\
    rsion\x18\x01\x20\x02(\rR\x07version\x12\x16\n\x06devkey\x18\x02\x20\x02\
    (\x0cR\x06devkey\x12\x1c\n\tsignature\x18\x03\x20\x02(\x0cR\tsignature\
    \x12\x1c\n\tuseragent\x18\x04\x20\x02(\tR\tuseragent\x12#\n\rcallback_ha\
    sh\x18\x05\x20\x02(\x0cR\x0ccallbackHash\"g\n\nClientInfo\x12\x18\n\x07l\
    imited\x18\x01\x20\x01(\x08R\x07limited\x12#\n\x02fb\x18\x02\x20\x01(\
    \x0b2\x13.ClientInfoFacebookR\x02fb\x12\x1a\n\x08language\x18\x03\x20\
    \x01(\tR\x08language\"3\n\x12ClientInfoFacebook\x12\x1d\n\nmachine_id\
    \x18\x01\x20\x01(\tR\tmachineId\"\xd4\x03\n\tAPWelcome\x12-\n\x12canonic\
    al_username\x18\n\x20\x02(\tR\x11canonicalUsername\x12A\n\x16account_typ\
    e_logged_in\x18\x14\x20\x02(\x0e2\x0c.AccountTypeR\x13accountTypeLoggedI\
    n\x12I\n\x1acredentials_type_logged_in\x18\x19\x20\x02(\x0e2\x0c.Account\
    TypeR\x17credentialsTypeLoggedIn\x12X\n\x1ereusable_auth_credentials_typ\
    e\x18\x1e\x20\x02(\x0e2\x13.AuthenticationTypeR\x1breusableAuthCredentia\
    lsType\x12:\n\x19reusable_auth_credentials\x18(\x20\x02(\x0cR\x17reusabl\
    eAuthCredentials\x12\x1d\n\nlfs_secret\x182\x20\x01(\x0cR\tlfsSecret\x12\
    /\n\x0caccount_info\x18<\x20\x01(\x0b2\x0c.AccountInfoR\x0baccountInfo\
    \x12$\n\x02fb\x18F\x20\x01(\x0b2\x14.AccountInfoFacebookR\x02fb\"n\n\x0b\
    AccountInfo\x12-\n\x07spotify\x18\x01\x20\x01(\x0b2\x13.AccountInfoSpoti\
    fyR\x07spotify\x120\n\x08facebook\x18\x02\x20\x01(\x0b2\x14.AccountInfoF\
    acebookR\x08facebook\"\x14\n\x12AccountInfoSpotify\"W\n\x13AccountInfoFa\
    cebook\x12!\n\x0caccess_token\x18\x01\x20\x01(\tR\x0baccessToken\x12\x1d\
    \n\nmachine_id\x18\x02\x20\x01(\tR\tmachineId*\xd6\x01\n\x12Authenticati\
    onType\x12\x1c\n\x18AUTHENTICATION_USER_PASS\x10\0\x12-\n)AUTHENTICATION\
    _STORED_SPOTIFY_CREDENTIALS\x10\x01\x12.\n*AUTHENTICATION_STORED_FACEBOO\
    K_CREDENTIALS\x10\x02\x12\x20\n\x1cAUTHENTICATION_SPOTIFY_TOKEN\x10\x03\
    \x12!\n\x1dAUTHENTICATION_FACEBOOK_TOKEN\x10\x04*Y\n\x0fAccountCreation\
    \x12\"\n\x1eACCOUNT_CREATION_ALWAYS_PROMPT\x10\x01\x12\"\n\x1eACCOUNT_CR\
    EATION_ALWAYS_CREATE\x10\x03*\x9d\x01\n\tCpuFamily\x12\x0f\n\x0bCPU_UNKN\
    OWN\x10\0\x12\x0b\n\x07CPU_X86\x10\x01\x12\x0e\n\nCPU_X86_64\x10\x02\x12\
    \x0b\n\x07CPU_PPC\x10\x03\x12\x0e\n\nCPU_PPC_64\x10\x04\x12\x0b\n\x07CPU\
    _ARM\x10\x05\x12\x0c\n\x08CPU_IA64\x10\x06\x12\n\n\x06CPU_SH\x10\x07\x12\
    \x0c\n\x08CPU_MIPS\x10\x08\x12\x10\n\x0cCPU_BLACKFIN\x10\t*K\n\x05Brand\
    \x12\x13\n\x0fBRAND_UNBRANDED\x10\0\x12\r\n\tBRAND_INQ\x10\x01\x12\r\n\t\
    BRAND_HTC\x10\x02\x12\x0f\n\x0bBRAND_NOKIA\x10\x03*\xd1\x02\n\x02Os\x12\
    \x0e\n\nOS_UNKNOWN\x10\0\x12\x0e\n\nOS_WINDOWS\x10\x01\x12\n\n\x06OS_OSX\
    \x10\x02\x12\r\n\tOS_IPHONE\x10\x03\x12\n\n\x06OS_S60\x10\x04\x12\x0c\n\
    \x08OS_LINUX\x10\x05\x12\x11\n\rOS_WINDOWS_CE\x10\x06\x12\x0e\n\nOS_ANDR\
    OID\x10\x07\x12\x0b\n\x07OS_PALM\x10\x08\x12\x0e\n\nOS_FREEBSD\x10\t\x12\
    \x11\n\rOS_BLACKBERRY\x10\n\x12\x0c\n\x08OS_SONOS\x10\x0b\x12\x0f\n\x0bO\
    S_LOGITECH\x10\x0c\x12\n\n\x06OS_WP7\x10\r\x12\x0c\n\x08OS_ONKYO\x10\x0e\
    \x12\x0e\n\nOS_PHILIPS\x10\x0f\x12\t\n\x05OS_WD\x10\x10\x12\x0c\n\x08OS_\
    VOLVO\x10\x11\x12\x0b\n\x07OS_TIVO\x10\x12\x12\x0b\n\x07OS_AWOX\x10\x13\
    \x12\x0c\n\x08OS_MEEGO\x10\x14\x12\r\n\tOS_QNXNTO\x10\x15\x12\n\n\x06OS_\
    BCO\x10\x16*(\n\x0bAccountType\x12\x0b\n\x07Spotify\x10\0\x12\x0c\n\x08F\
    acebook\x10\x01\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(16);
            messages.push(ClientResponseEncrypted::generated_message_descriptor_data());
            messages.push(LoginCredentials::generated_message_descriptor_data());
            messages.push(FingerprintResponseUnion::generated_message_descriptor_data());
            messages.push(FingerprintGrainResponse::generated_message_descriptor_data());
            messages.push(FingerprintHmacRipemdResponse::generated_message_descriptor_data());
            messages.push(PeerTicketUnion::generated_message_descriptor_data());
            messages.push(PeerTicketPublicKey::generated_message_descriptor_data());
            messages.push(PeerTicketOld::generated_message_descriptor_data());
            messages.push(SystemInfo::generated_message_descriptor_data());
            messages.push(LibspotifyAppKey::generated_message_descriptor_data());
            messages.push(ClientInfo::generated_message_descriptor_data());
            messages.push(ClientInfoFacebook::generated_message_descriptor_data());
            messages.push(APWelcome::generated_message_descriptor_data());
            messages.push(AccountInfo::generated_message_descriptor_data());
            messages.push(AccountInfoSpotify::generated_message_descriptor_data());
            messages.push(AccountInfoFacebook::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(6);
            enums.push(AuthenticationType::generated_enum_descriptor_data());
            enums.push(AccountCreation::generated_enum_descriptor_data());
            enums.push(CpuFamily::generated_enum_descriptor_data());
            enums.push(Brand::generated_enum_descriptor_data());
            enums.push(Os::generated_enum_descriptor_data());
            enums.push(AccountType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
